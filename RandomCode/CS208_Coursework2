{ assuming ‘∀x. ∀y. path(x, y) → path(y, x)’ with name ‘symmetry’ }
introduce h1;
{ assuming ‘¬path(a(), b())’ with name ‘h1’ }
not-intro h2;
{ assuming ‘path(b(), a())’ with name ‘h2’ }
use h1,
refuted by:
use symmetry,
instantiate with “b()”,
instantiate with “a()”,
apply with:
use h2,
done.
done.





{ assuming ‘∀x. ∀y. path(x, y) → path(y, x)’ with name ‘symmetry’ }
introduce h;
{ assuming ‘∀x. ∃y. path(x, y)’ with name ‘h’ }
introduce x;
{ let ‘x’ be an entity }
use h,
instantiate with “x”,
unpack as p1 and p2:
{ let ‘p1’ be an entity }
{ assuming ‘path(x, p1)’ with name ‘p2’ }
exists “p1”;
use symmetry,
instantiate with “x”,
instantiate with “p1”,
apply with:
use p2,
done.
done.





{ assuming ‘∀x. ∀y. ∀z. path(x, y) → path(y, z) → path(x, z)’ with name ‘transitivity’ }
introduce h1;
{ assuming ‘path(a(), b())’ with name ‘h1’ }
introduce h2;
{ assuming ‘path(b(), c())’ with name ‘h2’ }
use transitivity,
instantiate with “a()”,
instantiate with “b()”,
instantiate with “c()”,
apply with:
use h1,
done.
apply with:
use h2,
done.
done.





{ assuming ‘∀x. ∀y. ∀z. path(x, y) → path(y, z) → path(x, z)’ with name ‘transitivity’ }
{ assuming ‘∀x. ∀y. path(x, y) → path(y, x)’ with name ‘symmetry’ }
introduce h1;
{ assuming ‘∀x. ∃y. path(x, y)’ with name ‘h1’ }
introduce z;
{ let ‘z’ be an entity }
use h1,
instantiate with “z”,
unpack as p1 and p2:
{ let ‘p1’ be an entity }
{ assuming ‘path(z, p1)’ with name ‘p2’ }
use transitivity,
instantiate with “z”,
instantiate with “p1”,
instantiate with “z”,
apply with:
use p2,
done.
apply with:
use symmetry,
instantiate with “z”,
instantiate with “p1”,
apply with:
use p2,
done.
done.
done.





{ assuming ‘∀x. ∀y. path(x, y) ∨ path(y, x)’ with name ‘either-path’ }
introduce h1;
{ assuming ‘¬path(a(), b())’ with name ‘h1’ }
use either-path,
instantiate with “b()”,
instantiate with “a()”,
cases (1) h2 or (2) h3:
{ assuming ‘path(b(), a())’ with name ‘h2’ }
use h2,
done.
{ assuming ‘path(a(), b())’ with name ‘h3’ }
use h1,
refuted by:
use h3,
done.
