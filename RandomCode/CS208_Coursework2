{ assuming ‘∀x. ∀y. path(x, y) → path(y, x)’ with name ‘symmetry’ }
introduce h1;
{ assuming ‘¬path(a(), b())’ with name ‘h1’ }
not-intro h2;
{ assuming ‘path(b(), a())’ with name ‘h2’ }
use h1,
refuted by:
use symmetry,
instantiate with “b()”,
instantiate with “a()”,
apply with:
use h2,
done.
done.





{ assuming ‘∀x. ∀y. path(x, y) → path(y, x)’ with name ‘symmetry’ }
introduce h;
{ assuming ‘∀x. ∃y. path(x, y)’ with name ‘h’ }
introduce x;
{ let ‘x’ be an entity }
use h,
instantiate with “x”,
unpack as p1 and p2:
{ let ‘p1’ be an entity }
{ assuming ‘path(x, p1)’ with name ‘p2’ }
exists “p1”;
use symmetry,
instantiate with “x”,
instantiate with “p1”,
apply with:
use p2,
done.
done.





{ assuming ‘∀x. ∀y. ∀z. path(x, y) → path(y, z) → path(x, z)’ with name ‘transitivity’ }
introduce h1;
{ assuming ‘path(a(), b())’ with name ‘h1’ }
introduce h2;
{ assuming ‘path(b(), c())’ with name ‘h2’ }
use transitivity,
instantiate with “a()”,
instantiate with “b()”,
instantiate with “c()”,
apply with:
use h1,
done.
apply with:
use h2,
done.
done.





{ assuming ‘∀x. ∀y. ∀z. path(x, y) → path(y, z) → path(x, z)’ with name ‘transitivity’ }
{ assuming ‘∀x. ∀y. path(x, y) → path(y, x)’ with name ‘symmetry’ }
introduce h1;
{ assuming ‘∀x. ∃y. path(x, y)’ with name ‘h1’ }
introduce z;
{ let ‘z’ be an entity }
use h1,
instantiate with “z”,
unpack as p1 and p2:
{ let ‘p1’ be an entity }
{ assuming ‘path(z, p1)’ with name ‘p2’ }
use transitivity,
instantiate with “z”,
instantiate with “p1”,
instantiate with “z”,
apply with:
use p2,
done.
apply with:
use symmetry,
instantiate with “z”,
instantiate with “p1”,
apply with:
use p2,
done.
done.
done.





{ assuming ‘∀x. ∀y. path(x, y) ∨ path(y, x)’ with name ‘either-path’ }
introduce h1;
{ assuming ‘¬path(a(), b())’ with name ‘h1’ }
use either-path,
instantiate with “b()”,
instantiate with “a()”,
cases (1) h2 or (2) h3:
{ assuming ‘path(b(), a())’ with name ‘h2’ }
use h2,
done.
{ assuming ‘path(a(), b())’ with name ‘h3’ }
use h1,
refuted by:
use h3,
done.





{ assuming ‘∀x. ∀y. path(x, y) ∨ path(y, x)’ with name ‘either-path’ }
{ assuming ‘∀x. ∀y. path(x, y) → path(y, x)’ with name ‘symmetry’ }
introduce x;
{ let ‘x’ be an entity }
introduce y;
{ let ‘y’ be an entity }
use either-path,
instantiate with “x”,
instantiate with “y”,
cases (1) h1 or (2) h2:
{ assuming ‘path(x, y)’ with name ‘h1’ }
use h1,
done.
{ assuming ‘path(y, x)’ with name ‘h2’ }
use symmetry,
instantiate with “y”,
instantiate with “x”,
apply with:
use h2,
done.
done.





{ assuming ‘∀i. invoice(i) → (∃c. customer(c) ∧ custInvoice(c, i))’ with name ‘every-invoice-has-a-customer’ }
{ assuming ‘∃i. invoice(i)’ with name ‘exists-an-invoice’ }
use exists-an-invoice,
unpack as h1 and h2:
{ let ‘h1’ be an entity }
{ assuming ‘invoice(h1)’ with name ‘h2’ }
use every-invoice-has-a-customer,
instantiate with “h1”,
apply with:
use h2,
done.
unpack as h3 and h4:
{ let ‘h3’ be an entity }
{ assuming ‘customer(h3) ∧ custInvoice(h3, h1)’ with name ‘h4’ }
exists “h3”;
use h4,
first,
done.





hkdfhgkhdklfg
d;fgjlkjhfdkldg
gkldhfkghkld
ldhjfgkhjdk
kdhfgkhkdfg
sdlfjhklsdj





resetintroduce x;
{ let ‘x’ be an entity }
resetintroduce y;
{ let ‘y’ be an entity }
resetintroduce z;
{ let ‘z’ be an entity }
resetintroduce xequalsy;
{ assuming ‘x = y’ with name ‘xequalsy’ }
resetintroduce yequalsz;
{ assuming ‘y = z’ with name ‘yequalsz’ }
resetuse xequalsy,
resetrewrite→;
resetuse yequalsz,
resetrewrite→;
resetintroduce h;
{ assuming ‘P(z)’ with name ‘h’ }
resetuse h,
resetdone.
